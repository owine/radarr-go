// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: movies.sql

package postgres

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMonitoredMovies = `-- name: CountMonitoredMovies :one
SELECT COUNT(*) FROM movies WHERE monitored = true
`

func (q *Queries) CountMonitoredMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMonitoredMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovies = `-- name: CountMovies :one
SELECT COUNT(*) FROM movies
`

func (q *Queries) CountMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO movies (
    tmdb_id, imdb_id, title, original_title, sort_title,
    year, release_date, runtime, certification, overview,
    images, genres, studio, path, quality_profile_id,
    monitored, minimum_availability, status, has_file,
    folder_name, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    NOW(), NOW()
) RETURNING id
`

type CreateMovieParams struct {
	TmdbID              int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID              pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title               string           `db:"title" json:"title"`
	OriginalTitle       pgtype.Text      `db:"original_title" json:"original_title"`
	SortTitle           pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year                pgtype.Int4      `db:"year" json:"year"`
	ReleaseDate         pgtype.Timestamp `db:"release_date" json:"release_date"`
	Runtime             pgtype.Int4      `db:"runtime" json:"runtime"`
	Certification       pgtype.Text      `db:"certification" json:"certification"`
	Overview            pgtype.Text      `db:"overview" json:"overview"`
	Images              pgtype.Text      `db:"images" json:"images"`
	Genres              pgtype.Text      `db:"genres" json:"genres"`
	Studio              pgtype.Text      `db:"studio" json:"studio"`
	Path                pgtype.Text      `db:"path" json:"path"`
	QualityProfileID    int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored           pgtype.Bool      `db:"monitored" json:"monitored"`
	MinimumAvailability pgtype.Text      `db:"minimum_availability" json:"minimum_availability"`
	Status              pgtype.Text      `db:"status" json:"status"`
	HasFile             pgtype.Bool      `db:"has_file" json:"has_file"`
	FolderName          pgtype.Text      `db:"folder_name" json:"folder_name"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (int32, error) {
	row := q.db.QueryRow(ctx, createMovie,
		arg.TmdbID,
		arg.ImdbID,
		arg.Title,
		arg.OriginalTitle,
		arg.SortTitle,
		arg.Year,
		arg.ReleaseDate,
		arg.Runtime,
		arg.Certification,
		arg.Overview,
		arg.Images,
		arg.Genres,
		arg.Studio,
		arg.Path,
		arg.QualityProfileID,
		arg.Monitored,
		arg.MinimumAvailability,
		arg.Status,
		arg.HasFile,
		arg.FolderName,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE FROM movies WHERE id = $1
`

func (q *Queries) DeleteMovie(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMovie, id)
	return err
}

const getAllMovies = `-- name: GetAllMovies :many
SELECT
    id, tmdb_id, imdb_id, title, original_title, sort_title,
    year, release_date, runtime, certification, overview,
    images, genres, studio, path, quality_profile_id,
    monitored, minimum_availability, status, has_file,
    added, folder_name, created_at, updated_at
FROM movies
ORDER BY sort_title
`

type GetAllMoviesRow struct {
	ID                  int32            `db:"id" json:"id"`
	TmdbID              int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID              pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title               string           `db:"title" json:"title"`
	OriginalTitle       pgtype.Text      `db:"original_title" json:"original_title"`
	SortTitle           pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year                pgtype.Int4      `db:"year" json:"year"`
	ReleaseDate         pgtype.Timestamp `db:"release_date" json:"release_date"`
	Runtime             pgtype.Int4      `db:"runtime" json:"runtime"`
	Certification       pgtype.Text      `db:"certification" json:"certification"`
	Overview            pgtype.Text      `db:"overview" json:"overview"`
	Images              pgtype.Text      `db:"images" json:"images"`
	Genres              pgtype.Text      `db:"genres" json:"genres"`
	Studio              pgtype.Text      `db:"studio" json:"studio"`
	Path                pgtype.Text      `db:"path" json:"path"`
	QualityProfileID    int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored           pgtype.Bool      `db:"monitored" json:"monitored"`
	MinimumAvailability pgtype.Text      `db:"minimum_availability" json:"minimum_availability"`
	Status              pgtype.Text      `db:"status" json:"status"`
	HasFile             pgtype.Bool      `db:"has_file" json:"has_file"`
	Added               pgtype.Timestamp `db:"added" json:"added"`
	FolderName          pgtype.Text      `db:"folder_name" json:"folder_name"`
	CreatedAt           time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetAllMovies(ctx context.Context) ([]GetAllMoviesRow, error) {
	rows, err := q.db.Query(ctx, getAllMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllMoviesRow{}
	for rows.Next() {
		var i GetAllMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.SortTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Certification,
			&i.Overview,
			&i.Images,
			&i.Genres,
			&i.Studio,
			&i.Path,
			&i.QualityProfileID,
			&i.Monitored,
			&i.MinimumAvailability,
			&i.Status,
			&i.HasFile,
			&i.Added,
			&i.FolderName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitoredMovies = `-- name: GetMonitoredMovies :many
SELECT
    id, tmdb_id, imdb_id, title, original_title, sort_title,
    year, release_date, runtime, certification, overview,
    images, genres, studio, path, quality_profile_id,
    monitored, minimum_availability, status, has_file,
    added, folder_name, created_at, updated_at
FROM movies
WHERE monitored = true
ORDER BY sort_title
`

type GetMonitoredMoviesRow struct {
	ID                  int32            `db:"id" json:"id"`
	TmdbID              int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID              pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title               string           `db:"title" json:"title"`
	OriginalTitle       pgtype.Text      `db:"original_title" json:"original_title"`
	SortTitle           pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year                pgtype.Int4      `db:"year" json:"year"`
	ReleaseDate         pgtype.Timestamp `db:"release_date" json:"release_date"`
	Runtime             pgtype.Int4      `db:"runtime" json:"runtime"`
	Certification       pgtype.Text      `db:"certification" json:"certification"`
	Overview            pgtype.Text      `db:"overview" json:"overview"`
	Images              pgtype.Text      `db:"images" json:"images"`
	Genres              pgtype.Text      `db:"genres" json:"genres"`
	Studio              pgtype.Text      `db:"studio" json:"studio"`
	Path                pgtype.Text      `db:"path" json:"path"`
	QualityProfileID    int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored           pgtype.Bool      `db:"monitored" json:"monitored"`
	MinimumAvailability pgtype.Text      `db:"minimum_availability" json:"minimum_availability"`
	Status              pgtype.Text      `db:"status" json:"status"`
	HasFile             pgtype.Bool      `db:"has_file" json:"has_file"`
	Added               pgtype.Timestamp `db:"added" json:"added"`
	FolderName          pgtype.Text      `db:"folder_name" json:"folder_name"`
	CreatedAt           time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetMonitoredMovies(ctx context.Context) ([]GetMonitoredMoviesRow, error) {
	rows, err := q.db.Query(ctx, getMonitoredMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMonitoredMoviesRow{}
	for rows.Next() {
		var i GetMonitoredMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.SortTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Certification,
			&i.Overview,
			&i.Images,
			&i.Genres,
			&i.Studio,
			&i.Path,
			&i.QualityProfileID,
			&i.Monitored,
			&i.MinimumAvailability,
			&i.Status,
			&i.HasFile,
			&i.Added,
			&i.FolderName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieByID = `-- name: GetMovieByID :one
SELECT
    id, tmdb_id, imdb_id, title, original_title, sort_title,
    year, release_date, runtime, certification, overview,
    images, genres, studio, path, quality_profile_id,
    monitored, minimum_availability, status, has_file,
    added, folder_name, created_at, updated_at
FROM movies
WHERE id = $1
`

type GetMovieByIDRow struct {
	ID                  int32            `db:"id" json:"id"`
	TmdbID              int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID              pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title               string           `db:"title" json:"title"`
	OriginalTitle       pgtype.Text      `db:"original_title" json:"original_title"`
	SortTitle           pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year                pgtype.Int4      `db:"year" json:"year"`
	ReleaseDate         pgtype.Timestamp `db:"release_date" json:"release_date"`
	Runtime             pgtype.Int4      `db:"runtime" json:"runtime"`
	Certification       pgtype.Text      `db:"certification" json:"certification"`
	Overview            pgtype.Text      `db:"overview" json:"overview"`
	Images              pgtype.Text      `db:"images" json:"images"`
	Genres              pgtype.Text      `db:"genres" json:"genres"`
	Studio              pgtype.Text      `db:"studio" json:"studio"`
	Path                pgtype.Text      `db:"path" json:"path"`
	QualityProfileID    int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored           pgtype.Bool      `db:"monitored" json:"monitored"`
	MinimumAvailability pgtype.Text      `db:"minimum_availability" json:"minimum_availability"`
	Status              pgtype.Text      `db:"status" json:"status"`
	HasFile             pgtype.Bool      `db:"has_file" json:"has_file"`
	Added               pgtype.Timestamp `db:"added" json:"added"`
	FolderName          pgtype.Text      `db:"folder_name" json:"folder_name"`
	CreatedAt           time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetMovieByID(ctx context.Context, id int32) (GetMovieByIDRow, error) {
	row := q.db.QueryRow(ctx, getMovieByID, id)
	var i GetMovieByIDRow
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Title,
		&i.OriginalTitle,
		&i.SortTitle,
		&i.Year,
		&i.ReleaseDate,
		&i.Runtime,
		&i.Certification,
		&i.Overview,
		&i.Images,
		&i.Genres,
		&i.Studio,
		&i.Path,
		&i.QualityProfileID,
		&i.Monitored,
		&i.MinimumAvailability,
		&i.Status,
		&i.HasFile,
		&i.Added,
		&i.FolderName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMoviesByQualityProfile = `-- name: GetMoviesByQualityProfile :many
SELECT
    id, tmdb_id, imdb_id, title, original_title, sort_title,
    year, release_date, runtime, certification, overview,
    images, genres, studio, path, quality_profile_id,
    monitored, minimum_availability, status, has_file,
    added, folder_name, created_at, updated_at
FROM movies
WHERE quality_profile_id = $1
ORDER BY sort_title
`

type GetMoviesByQualityProfileRow struct {
	ID                  int32            `db:"id" json:"id"`
	TmdbID              int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID              pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title               string           `db:"title" json:"title"`
	OriginalTitle       pgtype.Text      `db:"original_title" json:"original_title"`
	SortTitle           pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year                pgtype.Int4      `db:"year" json:"year"`
	ReleaseDate         pgtype.Timestamp `db:"release_date" json:"release_date"`
	Runtime             pgtype.Int4      `db:"runtime" json:"runtime"`
	Certification       pgtype.Text      `db:"certification" json:"certification"`
	Overview            pgtype.Text      `db:"overview" json:"overview"`
	Images              pgtype.Text      `db:"images" json:"images"`
	Genres              pgtype.Text      `db:"genres" json:"genres"`
	Studio              pgtype.Text      `db:"studio" json:"studio"`
	Path                pgtype.Text      `db:"path" json:"path"`
	QualityProfileID    int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored           pgtype.Bool      `db:"monitored" json:"monitored"`
	MinimumAvailability pgtype.Text      `db:"minimum_availability" json:"minimum_availability"`
	Status              pgtype.Text      `db:"status" json:"status"`
	HasFile             pgtype.Bool      `db:"has_file" json:"has_file"`
	Added               pgtype.Timestamp `db:"added" json:"added"`
	FolderName          pgtype.Text      `db:"folder_name" json:"folder_name"`
	CreatedAt           time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetMoviesByQualityProfile(ctx context.Context, qualityProfileID int32) ([]GetMoviesByQualityProfileRow, error) {
	rows, err := q.db.Query(ctx, getMoviesByQualityProfile, qualityProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMoviesByQualityProfileRow{}
	for rows.Next() {
		var i GetMoviesByQualityProfileRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.SortTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Certification,
			&i.Overview,
			&i.Images,
			&i.Genres,
			&i.Studio,
			&i.Path,
			&i.QualityProfileID,
			&i.Monitored,
			&i.MinimumAvailability,
			&i.Status,
			&i.HasFile,
			&i.Added,
			&i.FolderName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMoviesWithFiles = `-- name: GetMoviesWithFiles :many
SELECT
    id, tmdb_id, imdb_id, title, original_title, sort_title,
    year, release_date, runtime, certification, overview,
    images, genres, studio, path, quality_profile_id,
    monitored, minimum_availability, status, has_file,
    added, folder_name, created_at, updated_at
FROM movies
WHERE has_file = true
ORDER BY sort_title
`

type GetMoviesWithFilesRow struct {
	ID                  int32            `db:"id" json:"id"`
	TmdbID              int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID              pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title               string           `db:"title" json:"title"`
	OriginalTitle       pgtype.Text      `db:"original_title" json:"original_title"`
	SortTitle           pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year                pgtype.Int4      `db:"year" json:"year"`
	ReleaseDate         pgtype.Timestamp `db:"release_date" json:"release_date"`
	Runtime             pgtype.Int4      `db:"runtime" json:"runtime"`
	Certification       pgtype.Text      `db:"certification" json:"certification"`
	Overview            pgtype.Text      `db:"overview" json:"overview"`
	Images              pgtype.Text      `db:"images" json:"images"`
	Genres              pgtype.Text      `db:"genres" json:"genres"`
	Studio              pgtype.Text      `db:"studio" json:"studio"`
	Path                pgtype.Text      `db:"path" json:"path"`
	QualityProfileID    int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored           pgtype.Bool      `db:"monitored" json:"monitored"`
	MinimumAvailability pgtype.Text      `db:"minimum_availability" json:"minimum_availability"`
	Status              pgtype.Text      `db:"status" json:"status"`
	HasFile             pgtype.Bool      `db:"has_file" json:"has_file"`
	Added               pgtype.Timestamp `db:"added" json:"added"`
	FolderName          pgtype.Text      `db:"folder_name" json:"folder_name"`
	CreatedAt           time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetMoviesWithFiles(ctx context.Context) ([]GetMoviesWithFilesRow, error) {
	rows, err := q.db.Query(ctx, getMoviesWithFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMoviesWithFilesRow{}
	for rows.Next() {
		var i GetMoviesWithFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.OriginalTitle,
			&i.SortTitle,
			&i.Year,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Certification,
			&i.Overview,
			&i.Images,
			&i.Genres,
			&i.Studio,
			&i.Path,
			&i.QualityProfileID,
			&i.Monitored,
			&i.MinimumAvailability,
			&i.Status,
			&i.HasFile,
			&i.Added,
			&i.FolderName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovie = `-- name: UpdateMovie :exec
UPDATE movies SET
    tmdb_id = $2,
    imdb_id = $3,
    title = $4,
    original_title = $5,
    sort_title = $6,
    year = $7,
    release_date = $8,
    runtime = $9,
    certification = $10,
    overview = $11,
    images = $12,
    genres = $13,
    studio = $14,
    path = $15,
    quality_profile_id = $16,
    monitored = $17,
    minimum_availability = $18,
    status = $19,
    has_file = $20,
    added = $21,
    folder_name = $22,
    updated_at = NOW()
WHERE id = $1
`

type UpdateMovieParams struct {
	ID                  int32            `db:"id" json:"id"`
	TmdbID              int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID              pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title               string           `db:"title" json:"title"`
	OriginalTitle       pgtype.Text      `db:"original_title" json:"original_title"`
	SortTitle           pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year                pgtype.Int4      `db:"year" json:"year"`
	ReleaseDate         pgtype.Timestamp `db:"release_date" json:"release_date"`
	Runtime             pgtype.Int4      `db:"runtime" json:"runtime"`
	Certification       pgtype.Text      `db:"certification" json:"certification"`
	Overview            pgtype.Text      `db:"overview" json:"overview"`
	Images              pgtype.Text      `db:"images" json:"images"`
	Genres              pgtype.Text      `db:"genres" json:"genres"`
	Studio              pgtype.Text      `db:"studio" json:"studio"`
	Path                pgtype.Text      `db:"path" json:"path"`
	QualityProfileID    int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored           pgtype.Bool      `db:"monitored" json:"monitored"`
	MinimumAvailability pgtype.Text      `db:"minimum_availability" json:"minimum_availability"`
	Status              pgtype.Text      `db:"status" json:"status"`
	HasFile             pgtype.Bool      `db:"has_file" json:"has_file"`
	Added               pgtype.Timestamp `db:"added" json:"added"`
	FolderName          pgtype.Text      `db:"folder_name" json:"folder_name"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) error {
	_, err := q.db.Exec(ctx, updateMovie,
		arg.ID,
		arg.TmdbID,
		arg.ImdbID,
		arg.Title,
		arg.OriginalTitle,
		arg.SortTitle,
		arg.Year,
		arg.ReleaseDate,
		arg.Runtime,
		arg.Certification,
		arg.Overview,
		arg.Images,
		arg.Genres,
		arg.Studio,
		arg.Path,
		arg.QualityProfileID,
		arg.Monitored,
		arg.MinimumAvailability,
		arg.Status,
		arg.HasFile,
		arg.Added,
		arg.FolderName,
	)
	return err
}
