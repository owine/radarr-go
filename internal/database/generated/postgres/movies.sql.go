// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: movies.sql

package postgres

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMonitoredMovies = `-- name: CountMonitoredMovies :one
SELECT COUNT(*) FROM movies WHERE monitored = true
`

func (q *Queries) CountMonitoredMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMonitoredMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMovies = `-- name: CountMovies :one
SELECT COUNT(*) FROM movies
`

func (q *Queries) CountMovies(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMovies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO movies (
    tmdb_id, imdb_id, title, sort_title,
    year, runtime, overview, path, quality_profile_id,
    monitored, status, has_file, folder_name
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id
`

type CreateMovieParams struct {
	TmdbID           int32       `db:"tmdb_id" json:"tmdb_id"`
	ImdbID           pgtype.Text `db:"imdb_id" json:"imdb_id"`
	Title            string      `db:"title" json:"title"`
	SortTitle        pgtype.Text `db:"sort_title" json:"sort_title"`
	Year             pgtype.Int4 `db:"year" json:"year"`
	Runtime          pgtype.Int4 `db:"runtime" json:"runtime"`
	Overview         pgtype.Text `db:"overview" json:"overview"`
	Path             pgtype.Text `db:"path" json:"path"`
	QualityProfileID int32       `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored        pgtype.Bool `db:"monitored" json:"monitored"`
	Status           pgtype.Text `db:"status" json:"status"`
	HasFile          pgtype.Bool `db:"has_file" json:"has_file"`
	FolderName       pgtype.Text `db:"folder_name" json:"folder_name"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (int32, error) {
	row := q.db.QueryRow(ctx, createMovie,
		arg.TmdbID,
		arg.ImdbID,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.Runtime,
		arg.Overview,
		arg.Path,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.HasFile,
		arg.FolderName,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE FROM movies WHERE id = $1
`

func (q *Queries) DeleteMovie(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMovie, id)
	return err
}

const getAllMovies = `-- name: GetAllMovies :many
SELECT
    id, tmdb_id, imdb_id, title, sort_title,
    year, runtime, overview, path, quality_profile_id,
    monitored, status, has_file,
    added, folder_name, created_at, updated_at
FROM movies
ORDER BY sort_title
`

type GetAllMoviesRow struct {
	ID               int32            `db:"id" json:"id"`
	TmdbID           int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID           pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title            string           `db:"title" json:"title"`
	SortTitle        pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year             pgtype.Int4      `db:"year" json:"year"`
	Runtime          pgtype.Int4      `db:"runtime" json:"runtime"`
	Overview         pgtype.Text      `db:"overview" json:"overview"`
	Path             pgtype.Text      `db:"path" json:"path"`
	QualityProfileID int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored        pgtype.Bool      `db:"monitored" json:"monitored"`
	Status           pgtype.Text      `db:"status" json:"status"`
	HasFile          pgtype.Bool      `db:"has_file" json:"has_file"`
	Added            pgtype.Timestamp `db:"added" json:"added"`
	FolderName       pgtype.Text      `db:"folder_name" json:"folder_name"`
	CreatedAt        time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetAllMovies(ctx context.Context) ([]GetAllMoviesRow, error) {
	rows, err := q.db.Query(ctx, getAllMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllMoviesRow{}
	for rows.Next() {
		var i GetAllMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.Runtime,
			&i.Overview,
			&i.Path,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.HasFile,
			&i.Added,
			&i.FolderName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitoredMovies = `-- name: GetMonitoredMovies :many
SELECT
    id, tmdb_id, imdb_id, title, sort_title,
    year, runtime, overview, path, quality_profile_id,
    monitored, status, has_file,
    added, folder_name, created_at, updated_at
FROM movies
WHERE monitored = true
ORDER BY sort_title
`

type GetMonitoredMoviesRow struct {
	ID               int32            `db:"id" json:"id"`
	TmdbID           int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID           pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title            string           `db:"title" json:"title"`
	SortTitle        pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year             pgtype.Int4      `db:"year" json:"year"`
	Runtime          pgtype.Int4      `db:"runtime" json:"runtime"`
	Overview         pgtype.Text      `db:"overview" json:"overview"`
	Path             pgtype.Text      `db:"path" json:"path"`
	QualityProfileID int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored        pgtype.Bool      `db:"monitored" json:"monitored"`
	Status           pgtype.Text      `db:"status" json:"status"`
	HasFile          pgtype.Bool      `db:"has_file" json:"has_file"`
	Added            pgtype.Timestamp `db:"added" json:"added"`
	FolderName       pgtype.Text      `db:"folder_name" json:"folder_name"`
	CreatedAt        time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetMonitoredMovies(ctx context.Context) ([]GetMonitoredMoviesRow, error) {
	rows, err := q.db.Query(ctx, getMonitoredMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMonitoredMoviesRow{}
	for rows.Next() {
		var i GetMonitoredMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.Runtime,
			&i.Overview,
			&i.Path,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.HasFile,
			&i.Added,
			&i.FolderName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieByID = `-- name: GetMovieByID :one
SELECT
    id, tmdb_id, imdb_id, title, sort_title,
    year, runtime, overview, path, quality_profile_id,
    monitored, status, has_file,
    added, folder_name, created_at, updated_at
FROM movies
WHERE id = $1
`

type GetMovieByIDRow struct {
	ID               int32            `db:"id" json:"id"`
	TmdbID           int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID           pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title            string           `db:"title" json:"title"`
	SortTitle        pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year             pgtype.Int4      `db:"year" json:"year"`
	Runtime          pgtype.Int4      `db:"runtime" json:"runtime"`
	Overview         pgtype.Text      `db:"overview" json:"overview"`
	Path             pgtype.Text      `db:"path" json:"path"`
	QualityProfileID int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored        pgtype.Bool      `db:"monitored" json:"monitored"`
	Status           pgtype.Text      `db:"status" json:"status"`
	HasFile          pgtype.Bool      `db:"has_file" json:"has_file"`
	Added            pgtype.Timestamp `db:"added" json:"added"`
	FolderName       pgtype.Text      `db:"folder_name" json:"folder_name"`
	CreatedAt        time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetMovieByID(ctx context.Context, id int32) (GetMovieByIDRow, error) {
	row := q.db.QueryRow(ctx, getMovieByID, id)
	var i GetMovieByIDRow
	err := row.Scan(
		&i.ID,
		&i.TmdbID,
		&i.ImdbID,
		&i.Title,
		&i.SortTitle,
		&i.Year,
		&i.Runtime,
		&i.Overview,
		&i.Path,
		&i.QualityProfileID,
		&i.Monitored,
		&i.Status,
		&i.HasFile,
		&i.Added,
		&i.FolderName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMoviesByQualityProfile = `-- name: GetMoviesByQualityProfile :many
SELECT
    id, tmdb_id, imdb_id, title, sort_title,
    year, runtime, overview, path, quality_profile_id,
    monitored, status, has_file,
    added, folder_name, created_at, updated_at
FROM movies
WHERE quality_profile_id = $1
ORDER BY sort_title
`

type GetMoviesByQualityProfileRow struct {
	ID               int32            `db:"id" json:"id"`
	TmdbID           int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID           pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title            string           `db:"title" json:"title"`
	SortTitle        pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year             pgtype.Int4      `db:"year" json:"year"`
	Runtime          pgtype.Int4      `db:"runtime" json:"runtime"`
	Overview         pgtype.Text      `db:"overview" json:"overview"`
	Path             pgtype.Text      `db:"path" json:"path"`
	QualityProfileID int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored        pgtype.Bool      `db:"monitored" json:"monitored"`
	Status           pgtype.Text      `db:"status" json:"status"`
	HasFile          pgtype.Bool      `db:"has_file" json:"has_file"`
	Added            pgtype.Timestamp `db:"added" json:"added"`
	FolderName       pgtype.Text      `db:"folder_name" json:"folder_name"`
	CreatedAt        time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetMoviesByQualityProfile(ctx context.Context, qualityProfileID int32) ([]GetMoviesByQualityProfileRow, error) {
	rows, err := q.db.Query(ctx, getMoviesByQualityProfile, qualityProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMoviesByQualityProfileRow{}
	for rows.Next() {
		var i GetMoviesByQualityProfileRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.Runtime,
			&i.Overview,
			&i.Path,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.HasFile,
			&i.Added,
			&i.FolderName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMoviesWithFiles = `-- name: GetMoviesWithFiles :many
SELECT
    id, tmdb_id, imdb_id, title, sort_title,
    year, runtime, overview, path, quality_profile_id,
    monitored, status, has_file,
    added, folder_name, created_at, updated_at
FROM movies
WHERE has_file = true
ORDER BY sort_title
`

type GetMoviesWithFilesRow struct {
	ID               int32            `db:"id" json:"id"`
	TmdbID           int32            `db:"tmdb_id" json:"tmdb_id"`
	ImdbID           pgtype.Text      `db:"imdb_id" json:"imdb_id"`
	Title            string           `db:"title" json:"title"`
	SortTitle        pgtype.Text      `db:"sort_title" json:"sort_title"`
	Year             pgtype.Int4      `db:"year" json:"year"`
	Runtime          pgtype.Int4      `db:"runtime" json:"runtime"`
	Overview         pgtype.Text      `db:"overview" json:"overview"`
	Path             pgtype.Text      `db:"path" json:"path"`
	QualityProfileID int32            `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored        pgtype.Bool      `db:"monitored" json:"monitored"`
	Status           pgtype.Text      `db:"status" json:"status"`
	HasFile          pgtype.Bool      `db:"has_file" json:"has_file"`
	Added            pgtype.Timestamp `db:"added" json:"added"`
	FolderName       pgtype.Text      `db:"folder_name" json:"folder_name"`
	CreatedAt        time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetMoviesWithFiles(ctx context.Context) ([]GetMoviesWithFilesRow, error) {
	rows, err := q.db.Query(ctx, getMoviesWithFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMoviesWithFilesRow{}
	for rows.Next() {
		var i GetMoviesWithFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.ImdbID,
			&i.Title,
			&i.SortTitle,
			&i.Year,
			&i.Runtime,
			&i.Overview,
			&i.Path,
			&i.QualityProfileID,
			&i.Monitored,
			&i.Status,
			&i.HasFile,
			&i.Added,
			&i.FolderName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovie = `-- name: UpdateMovie :exec
UPDATE movies SET
    tmdb_id = $2,
    imdb_id = $3,
    title = $4,
    sort_title = $5,
    year = $6,
    runtime = $7,
    overview = $8,
    path = $9,
    quality_profile_id = $10,
    monitored = $11,
    status = $12,
    has_file = $13,
    folder_name = $14,
    updated_at = NOW()
WHERE id = $1
`

type UpdateMovieParams struct {
	ID               int32       `db:"id" json:"id"`
	TmdbID           int32       `db:"tmdb_id" json:"tmdb_id"`
	ImdbID           pgtype.Text `db:"imdb_id" json:"imdb_id"`
	Title            string      `db:"title" json:"title"`
	SortTitle        pgtype.Text `db:"sort_title" json:"sort_title"`
	Year             pgtype.Int4 `db:"year" json:"year"`
	Runtime          pgtype.Int4 `db:"runtime" json:"runtime"`
	Overview         pgtype.Text `db:"overview" json:"overview"`
	Path             pgtype.Text `db:"path" json:"path"`
	QualityProfileID int32       `db:"quality_profile_id" json:"quality_profile_id"`
	Monitored        pgtype.Bool `db:"monitored" json:"monitored"`
	Status           pgtype.Text `db:"status" json:"status"`
	HasFile          pgtype.Bool `db:"has_file" json:"has_file"`
	FolderName       pgtype.Text `db:"folder_name" json:"folder_name"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) error {
	_, err := q.db.Exec(ctx, updateMovie,
		arg.ID,
		arg.TmdbID,
		arg.ImdbID,
		arg.Title,
		arg.SortTitle,
		arg.Year,
		arg.Runtime,
		arg.Overview,
		arg.Path,
		arg.QualityProfileID,
		arg.Monitored,
		arg.Status,
		arg.HasFile,
		arg.FolderName,
	)
	return err
}
